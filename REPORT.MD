## Part 1. Запуск нескольких docker-контейнеров с использованием docker compose

   Скачиваем **git lfs** `sudo apt install git-lfs`

   В репозитории проекта делаем `git lfs pull`

   Иначе в файлах **maven-wrapper.jar** будут лежать ссылки на репозитории, а не само содержимое **.jar** файла.
   
   Для кадого сервиса пишем **Dockerfile** подобно этому:

   ![dockerfile](screenshots/image1.png)

   Берем за основу один из образов, содержащий все необходимое для сборки проекта. Также надо удалить переменную окружения **MAVEN_CONFIG** внутри контейнера и присвоить ей значение равное " ". Это делаем из за того что внутри образа эта переменная определена для своих нужд и по каким-то причинам конфликтует с переменной необходимой для сборки образа. Далее берем за основу легкий образ, копируем туда полученный **.jar** - файл, определяем переменные окружения. Точкой входа в контейнер является **wait-for-it.sh** скрипт, который проверяет поднят ли контейнер с **postgres** базой данных, и, если поднят, запускает полученный ранее **.jar** - файл.
   
   ![images_size](screenshots/image3.png)![database_size](screenshots/image4.png)

   Пишем **docker-compose.yaml**:

   ![docker-compose](screenshots/image2.png)

   Указываем цели для сборки образов, прокидываем необходимые порты + добавляем еще один сервис **RabbitMQ**

   ![docker_ps](screenshots/image5.png)
   
   Скачиваем **Postman**, импортируем файл для тестов:

   ![postman](screenshots/image6.png)

## Part 2. Создание виртуальных машин

   Т.к. **Vagrant** плохо работает с **VirtualBox** из под **WSL** запускать его будем в **Powershell**.

   Делаем `git clone` проекта, доабвляем в **.gitattributes** параметр ***text eol=lf** чтобы окончание строк файлов было в LF-формате(нужно чтобы не сломалась сборка проекта).

   Инициализируем **Vagrant** в корне проекта командой `vagrant init ubuntu/focal64 --box-version 20240821.0.1`, устанавливаем образ **Ubuntu** и его версию.

   Пишем **Vagrantfile**:

   ![vagrantfile](screenshots/image7.png)

   В нем также указываем образ, его версию, наименование провайдера **VirtualBox**, имя машины, её ресуры и имя хоста.

   Указываем **.sh** скрипт который должен быть запущен при запуске машины. (Скрипт копирует исходники проекта, которые **Vagrant** сам закинул на виртуалку, в рабочую директорию)

   ![task2.sh](screenshots/image8.png)

   Запускаем создание машины командой `vagrant up`

   Заходим внутрь командой `vagrant ssh`

   Видим исходникики в папке workdir

   ![src](screenshots/image9.png)

   Останавливаем машину командой `vagrant halt` и уничтожаем её командой `vagrant destroy`

   ![destroy](screenshots/image10.png)

## Part 3. Создание простейшего docker swarm

   Обновляем **Vagrantfile** для создания трех машин

   ![vagrantfile](screenshots/image11.png)

   Указываем в нем для каждой машины выделяемую память и количество ядер, создаем внутреннюю сеть. Также для **manager** и **worker** нод указываем **.sh** файлы, запускающиеся при запусе:

   manager:

   ![manager](screenshots/image12.png)

   Скрипт устанавливает докер, создает рабочую папку и закидывает туда исходники, а также инициализирует машину как **manager** ноду и копирует токен для подключения **worker** нод в общую для всех машин директорию.

   worker:

   ![worker](screenshots/image13.png)

   Скрипт устанавливает докер, выполняет подключение машины к **manager** ноде.

   Следующим шагом загружаем докер-образы сервисов на **docker hub**, т.к. **docker swarm** не умеет билдить образы по докерфайлам.

   ![docker-hub](screenshots/image14.png)

   Изменим **docker-compose.yaml**

   ![docker-compose](screenshots/image15.png)

   Поднимаем машины командой `vagrant up`
   
   Подключаемся к **manager** ноде командой `vagrant ssh manager01`

   Запускаем стек сервисов командой `sudo docker stack deploy -c docker-compose.yaml app`

   Имеем:

   ![service-ls](screenshots/image16.png)

   Далее настроим **nginx** прокси сервер. Для этого создадим еще одну директорию для сервиса. В ней будет лежать **Dockerfile** с описанным образом, **nginx.conf**, wait-for-it.sh.

   ![nginx-dockerfile](screenshots/image17.png)

   Из важного: точкой входа в контейнер определим последовательность **wait-for-it.sh** скриптов, которые проверяют доступны ли сервисы, с которыми **nginx** будет непосредственно работать, и только после этого запускает **nginx**.

   ![nginx.conf](screenshots/image18.png)

   В конфиге указываем сервера для проксирования и блоки **server** которые слушают порты **8081** и **8087** и проксируют запросы в определенные сервисы.

   Необходимо также загрузить образ на **docker hub** и указать сервис и прокинутые порты в **docker-compose.yaml**. Это было показано выше.

   Прогоняем тесты через **postman** (пришлось изменить адрес **localhost** на внешний адрес одной из поднятых машин)

   ![postman](screenshots/image19.png)

   Посмотрим распределение контейнеров по узлам:

   manager01:

   ![manager01-ps](screenshots/image20.png)

   worker01:

   ![worker01-ps](screenshots/image21.png)

   worker02:

   ![worker02-ps](screenshots/image22.png)

   Поставим **Portainer** отдельным стеком

   Для удобства написал **.sh** скрипт для запуска основного стека и стека с портейнером

   ![start.sh](screenshots/image23.png)

   Скрипт деплоит основной стек, скачивает **.yaml** файл с описанными сервисами портейнера и деплоит его. Портейнер раскидывает агент-сервисы на все машины и управляющий сервис на **manager** ноду.

   Заходим в **Portainer** через браузер по порту **:9000**

   ![dashboard](screenshots/image24.png)

   ![services](screenshots/image25.png)

   ![contaners](screenshots/image26.png)